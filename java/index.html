<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword" content="">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="/img/marmot.jpg">
    <link rel="alternate" type="application/atom+xml" title="marmot" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        Java学习之路｜marmot&#39;s blog
        
    </title>

    <link rel="canonical" href="https://www.marmot.vip/java/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/blog-style.css">


    <!-- Pygments Github CSS -->
    
<link rel="stylesheet" href="/css/syntax.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<style>

    header.intro-header {
        background-image: url('img/back.jpg')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/">
                <span class="brand-logo">
                    marmot
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
					
                    
                        
							
                        <li>
                            <a href="/Tags/">Tags</a>
                        </li>
							
						
                    
                        
							
                        <li>
                            <a href="/work/">work</a>
                        </li>
							
						
                    
					
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img"
     src="undefinedimg/back.jpg">


<style>
    
    header.intro-header {
        background-image: url('img/back.jpgundefined')
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>Java学习之路</h1>
                    
                    <h2 class="subheading">Hi,World!</h2>
                    
                    <span class="meta">
                         作者 marmot
                        <span>
                          日期 2021-07-04
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                        <a class="tag" href="/tags/#Java"
                           title="Java">Java</a>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            Java学习之路
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <h4 id="Java语言基础"><a href="#Java语言基础" class="headerlink" title="Java语言基础"></a>Java语言基础</h4><p>//单行注释</p>
<p>/* </p>
<p>多行注释</p>
<p>*/</p>
<p>/**</p>
<p>*多行注释  （工具解析）</p>
<p>*</p>
<p>*/</p>
<p>public 公开的 static静态的 void表示空 main表示方法名 （String[] args) 形参</p>
<p>1 标识符（类名 方法名 常量 接口名 变量名）</p>
<p>2 规则 数字字母下划线美元  不可以数字开头 严格区分大小写 不可使用关键字</p>
<p>java 所有的字符串型数据使用双引号</p>
<p>​        所有的字符型数据使用单引号</p>
<p>变量：  数据类型+ 变量名称</p>
<p>int整数型 </p>
<p>java代码自上而下执行</p>
<p>变量作用域 ：变量支持的允许范围，在什么范围之内可以访问</p>
<p>出大括号范围 </p>
<p>局部变量：在方法提中声明的变量叫局部变量</p>
<p>成员变量：在方法体外【类体之内】声明的变量叫成员变量</p>
<p>类体中不可编写Java语句</p>
<p>数据类型</p>
<p>1 基本数据类型</p>
<p>第一条：整数型：bytes shor in long</p>
<p>第二类：浮点型：float double</p>
<p>第三类：布尔型：boolen</p>
<p>第四类：字符型： char</p>
<p>2 引用数据类型</p>
<p>字符串属于引用类型</p>
<p>基本数字类型占用空间大小：</p>
<p>基本数据类型                       占用空间大小单位字节</p>
<p>-——————————————————————</p>
<p>byte                        1    -128~127</p>
<p>short                     2    -32768~32767</p>
<p>int                         4                成员变量默认赋值为0</p>
<p>long                        8</p>
<p>float                        4                0.0</p>
<p>double                    8                0.0</p>
<p>boolean                    1                false</p>
<p>char                        2    0-65535        \u0000</p>
<p>ASCII码彩用一个字节编码</p>
<p>GB2312 GBK GB18030中文编码</p>
<p>unicode 统一所有文字 utf-8 </p>
<p>java源代码使用unicode编码</p>
<p>解码和编码</p>
<p>\转义功能 \n换行符</p>
<p>println输出后换行</p>
<p>print输出不换行</p>
<p>\t制表符 tab键</p>
<p>native2ascii可将文件转换为unicode编码格式</p>
<p>整数型默认当作int处理，要当作long处理  数值后加L/l</p>
<p>大容量变量变小容量变量  编译会发生错误</p>
<p><img src="/java/clipboard.png" alt="img"></p>
<p>大容量转小容量需要添加强制转换符号，</p>
<p>一个整数变量没有超出byte类型取值范围，字面值可以直接赋值给byte类型的变量</p>
<p>long k = 221231231l;</p>
<p>int e = (int) k;</p>
<p>强制进行转换</p>
<p><strong>原码补码反码</strong></p>
<p>正整数的补码   二进制表示与原码相同 </p>
<p>负整数：所有位取反后加1</p>
<p>计算机中 数值一律用补码进行表示和存储</p>
<p>将字面值当作float类型处理 要在子面子后添加f/F</p>
<p><img src="/java/image001.png" alt="img"></p>
<p>运算符号：</p>
<p>算数运算符 + - * / ++  – %</p>
<p>关系运算符： &lt; &lt;= &gt; &gt;= == !</p>
<p>布尔运算符 &amp;&amp; || &amp; !</p>
<p>++自加1   </p>
<p>–自减一</p>
<p>int k=1;</p>
<p>k++; k=2     b = k++ 先进行赋值运算 再进行+1</p>
<p>int k=2; </p>
<p>++k; k=3 运算结束都会加1   b = ++ k   先运算  再赋值</p>
<p>关系运算符  &gt;大于 &gt;=大于等于 &lt;小于 &lt;=小于等于 ==等于 != 不等于</p>
<p><strong>逻辑运算符</strong></p>
<p> &amp;与  两边都为真为真</p>
<p>  |或者  有真则真</p>
<p>  !非  取反</p>
<p> ^异或   两边算子只要不一样就是true</p>
<p> &amp;&amp;短路与    短路与存在短路现象   与逻辑与结果一致</p>
<p> ||短路或       短路或存在短路现象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">11</span></span><br><span class="line"><span class="keyword">int</span> y = <span class="number">8</span></span><br><span class="line">system.out.println(x&lt;y &amp; ++x&lt;y)</span><br><span class="line">system.out.println(x)  /x=<span class="number">11</span></span><br><span class="line">system.out.println(x&lt;y &amp;&amp; ++x&lt;y)</span><br><span class="line">system.out.println(x)  /x=<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>前一个算子为false 后面的不再执行</p>
<p>短路与或效率高</p>
<p>位运算符 ：</p>
<p>&amp;  *</p>
<p>赋值类运算符：</p>
<p>基本：=  </p>
<p> +=  x+= y  x=(类型byte)(x+y)</p>
<p> -=</p>
<p> /=</p>
<p> %=</p>
<p>字符串连接：+   运算符左右只要有一个是字符串 就会拼接成字符串</p>
<p><strong>三元运算符：</strong></p>
<p>布尔表达式？表达式1：表达式2；</p>
<p><strong>控制语句</strong></p>
<p><strong>选择控制</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">if</span>/ <span class="function"><span class="keyword">if</span> <span class="keyword">else</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(条件)</span></span>&#123;</span><br><span class="line">	java语句；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(布尔表达式）&#123;</span><br><span class="line">	java语句；</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	java语句；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">	java语句；</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">    java语句；</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">    java语句；</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    java语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要有一个分支执行，if语句全部结束</p>
<p>有else的必有分支被执行</p>
<p>所有的控制都可互相嵌套使用，只要合理嵌套</p>
<p>if语句只有一条java语句，大括号可不写 </p>
<p>从键盘接受输入</p>
<p>java.util.Scanner s = new java.util.Scanner(System.in);</p>
<p>调用 s.next()方法接受输入</p>
<p>  nextint输入数字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- <span class="function"><span class="keyword">switch</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="title">switch</span><span class="params">(i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		code;</span><br><span class="line">		code;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">       	code;</span><br><span class="line">		code;</span><br><span class="line">		<span class="keyword">break</span>; </span><br><span class="line"><span class="keyword">default</span> :</span><br><span class="line">		code;</span><br><span class="line">		code;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch后小括号中的数据与case后的数据进行匹配 匹配成功的执行分支代码</p>
<p>匹配成功的分支执行代码后面有break语句的话。swit语句终止</p>
<p>没有break，直接进入下一个分支执行代码  case穿透现象</p>
<p>case可以合并</p>
<p>case 1 : case 2 : case 3 : case 4:</p>
<p>code1</p>
<p><strong>循环结构</strong></p>
<ul>
<li>for</li>
</ul>
<p>在程序中反复执行一段代码</p>
<p>for(初始化表达式;布尔表达式;更新表达式){</p>
<p>code;</p>
<p>}均可省略</p>
<p>初始化表达式最先执行并且执行一次</p>
<ul>
<li>while</li>
</ul>
<p>while(布尔表达式){</p>
<p>循环体；</p>
<p>}</p>
<p>布尔表达式为false时，循环结束。为真继续执行</p>
<ul>
<li>do while  </li>
</ul>
<p>do{</p>
<p>} </p>
<p>while()；</p>
<p><strong>控制循环</strong></p>
<ul>
<li>break</li>
</ul>
<p>break可以在循环中使用用来终止循环的执行</p>
<p>可用在switch中中断匹配</p>
<p>默认中break中断最近的循环 </p>
<ul>
<li>continue</li>
</ul>
<p>表示继续 下一个</p>
<p>continue；用老控制循环的执行</p>
<p>表示本次循环不执行</p>
<p><strong>方法</strong></p>
<p>方法的基础:一段代码片段，可完成某个可重复使用的特定功能</p>
<p>类中可定义多个方法</p>
<p>方法的重载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">classname.sumInt(a,b)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sumInt</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c = a + b;</span><br><span class="line">	System.out.printlb(<span class="string">&#x27;a+b&#x27;</span>+<span class="string">&#x27;=&#x27;</span>+c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sumInt</span><span class="params">(String a,String b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c = a + b;</span><br><span class="line">	System.out.printlb(<span class="string">&#x27;a+b&#x27;</span>+<span class="string">&#x27;=&#x27;</span>+c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法定义，语法结构：</p>
<p>修饰符列表 返回值类型 方法名（形参){</p>
<p>方法体；</p>
<p>}</p>
<p>1修饰符列表：public static  ,可选项，非必需</p>
<p>若有关键字。调用方法：类名.方法名(实际参数);</p>
<p>2返回值类型：一个方法可以完成某个特定功能，功能结束后需要返回最终执行结果，执行结果可能是一个存在的数据，只要是数据就有类型。</p>
<p>返回值类型：Eg：任何java的数据类型</p>
<p>也可能方法执行结束后不反悔任何数据，Java规定，方法结束不反悔任何数据的话，返回值类型位置必须编写void关键字</p>
<p>返回值类型若不是void，表示这个方法执行结束后必须返回一个具体的数值，当方法执行结束的税后没有返回任何数据的话编译器报错。</p>
<p>return 值。 值的类型必须和方法的返回值类型一致</p>
<p>返回值类型为void的时候，不能编写return 值，但可以编写return ;</p>
<p>带有return关键字的语句执行，return所在的方法执行结束</p>
<p>形式参数列表：可以有多个参数，局部变量。形参的个数从0-n</p>
<p>方法在调用的时候传递的参数成为实际参数</p>
<p>实参列表与形参列表必须满足类型相同，数量相同</p>
<p>方法体中的代码自上而下执行，</p>
<p> 方法定义修饰带static的方法可以不写类名进行调用</p>
<p>调用其他类的方法必须带类名  </p>
<p>方法的返回值类型不是void的时候</p>
<p>要求方法必须保证百分比执行return进行值的返回</p>
<p>return执行后，所在的方法结束</p>
<p>在统一个作用域中，return下不可编写任何代码</p>
<p>返回值类型为void的方法中使用return；语句</p>
<p>return；语句终止方法执行</p>
<p>main方法中也可以添加return;</p>
<p><strong>方法在执行过程中，内存分配</strong></p>
<ol>
<li><p>方法只是定义，未调用不会分配内存空间。调用方法的时候，才会动态的给这个方法分配所需的内存空间</p>
</li>
<li><p>在JVM内存主要内存空间划分：</p>
<p>​    *方法区内存</p>
<p>​    *堆内存</p>
<p>​    *栈内存</p>
</li>
<li><p>关于栈数据结构</p>
<p>​    *stack 数据结构</p>
<p>​    *数据结构反应的是数据的存储形态</p>
<p>​    *数据结构是独立的学科</p>
<p>​    *数组、队列、链表、栈、二叉树、哈希表</p>
<p>​    栈帧永远指向栈顶元素</p>
<p>​    栈顶元素处于活跃状态，其他元素静止</p>
<p>​    压栈、入栈、push</p>
<p>​    弹栈、出栈、pop</p>
<p>​    存储数据的特点：先进后出，后进先出</p>
</li>
<li><p>方法指向内存分配：</p>
<p>​    方法执行的时候代码片段存放?</p>
<p>​    方法代码片段放在方法区内存中，属于.class字节码文件的一部分，字节码文件在类加载的时候，将其放到了方法区中，所有JVM的三块主要的内存空间中方法区内存最先有数据。</p>
<p>​    代码片段虽然在方法区内存中只有一份。但是可以被重复调用</p>
<p>​    每一次调用此方法的时候，需要给该方法分配独立的活动场所，在栈内存中分配</p>
<p>​    栈内存中分配方法运行的所属内存空间</p>
<p>​    方法执行的时候执行过程的内存在哪里分配</p>
</li>
<li><p>方法在调用的瞬间，会给该方法分配独立的内存空间，在栈中分配，此时发送压栈动作，方法执行结束之后，会给该方法分配的内存空间全部释放，此时发生弹栈动作</p>
<p>​    压栈:给方法分配内存</p>
<p>​    弹栈：释放方法的内存空间</p>
</li>
<li><p>局部变量在方法体中声明，局部变量在运行阶段内存在栈中分配，</p>
</li>
</ol>
<p><strong>方法初步：</strong></p>
<p>方法执行过程中的内存分配</p>
<p>方法调用过程中参数传递的是值</p>
<p><img src="/java/image2.png" alt="img"></p>
<p>方法的重载机制</p>
<p>多个方法功能类似可用方法重载，方便记忆及使用</p>
<p>方法同一个类中：</p>
<p>方法名相同。参数列表不同，参数数量不同，参数顺序不同</p>
<p>方法重载的具体应用：</p>
<p>方法的递归调用</p>
<p>在方法自己中调用方法本身，代码片段只有一份，但是可以被重复调用，只要调用方法，栈内存中就会分配一块新的空间。递归很耗内存</p>
<p>栈内存溢出错误，JVM停止运行，</p>
<p>递归在运行时太深也会溢出即使有退出语句</p>
<h4 id="Java修饰符"><a href="#Java修饰符" class="headerlink" title="Java修饰符"></a>Java修饰符</h4><ul>
<li><p>默认访问修饰符-不使用任何关键字</p>
<p>​    使用默认修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为public static final，而接口中的方法默认情况下访问权限是public</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">&quot;lisi&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">processorder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>私有访问修饰符-private</p>
<p>​    私有访问修饰符是最严格的访问级别。被private声明的方法、变量和构造方法只能被所属类访问，并且接口和类不可被private修饰。</p>
<p>声明为私有访问类型的变量只能通过类中公共的getter方法被外部类访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getname</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setname</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>公共访问修饰符-public</p>
<p>​    被声明为public的类、方法、构造方法和接口都能被任何其他类访问。如果几个相互访问的public类分布在不同的包中，则需要导入相应public类所在的包。</p>
</li>
<li><p>受保护的访问修饰符-protected</p>
<p>​    </p>
</li>
</ul>
<p><strong>面向对象</strong></p>
<p><strong>核心机制</strong></p>
<p>面向过程与面向对象的区别</p>
<p>面向过程：实现的具体过程。关注因果关系的过程</p>
<p>有点：对于业务逻辑简单的程序可以快速开发，前期投入低</p>
<p>缺点：很难解决业务复杂的逻辑。面向过程的方式导致元素之间的耦合度非常高，其中一环出问题，就会收到影响。没有独立提的概念，无法打到附件复用</p>
<p>c面向过程 c++半面向对象 java纯面向对象</p>
<p>面向对象：面向单独的对象。每个对象都是独立的单元，在给定的环境中各个单元协作工作运行</p>
<p>优点：耦合度低，扩展能力强。更容易解决现实世界更复杂的业务逻辑问题。</p>
<p>缺点：前期投入成本较高，需要进行独立提的抽取，大量的系统分析设计。</p>
<p>面向对象的三特征</p>
<p>封装</p>
<p>继承</p>
<p>多态</p>
<p>开发过程：面向对象的分析，面向对象的设计，面向对象的编程。</p>
<p>面向对象的概念</p>
<p>类：是一个模板。是一个不存在的概念，代表一类事物，对象A与对象B之间有共同特征，进行抽象总结出的模板。</p>
<p>对象：是真实存在的个体。</p>
<p>软件开发过程：观察现实世界，从现实世界中寻找对象，形成一个模板类</p>
<p>通过Java代码来表述一个类。再通过类创建对象，然后让对象协作工作形成一个系统。</p>
<p>类 –》 对象  通过实例化</p>
<p>对象 –抽象&gt;  类</p>
<p>类的主要描述：状态+动作（属性+方法）</p>
<ul>
<li><p>ooa 面向对象分析</p>
</li>
<li><p>ood 面向对象设计</p>
</li>
<li><p>oop 面向对象编程</p>
</li>
</ul>
<p>对象与对象之间有共同特征，也有数据的差异</p>
<p><strong>类的定义</strong></p>
<p>​    类的修饰符 class 类名 extends 父对象名 implements 接口名称{}</p>
<p>状态信息+动作信息</p>
<p>属性通常采用变量的形式来定义</p>
<p>类的修饰符 class 类名 {</p>
<p>​        在类体中，方法体之外的定义成为成员变量</p>
<p>​        成员变量没有赋值，系统默认赋值，向0看起</p>
<p>​        方法描述对象的动作信息</p>
<p>}</p>
<p>Java 语言中包括两种数据类型：</p>
<p>-基本数据类型</p>
<p>byte、int、long、bool、short、char、double、float</p>
<p>-引用数据类型</p>
<p>所有的class都是引用数据类型、String、System、User、Product、Customer</p>
<p>对象的创建及使用</p>
<p>实例化类：new classname();</p>
<p>new  是Java语言中的一个运算符。</p>
<p>作用：在JVM堆内存当中开辟新的内存空间</p>
<p>栈内存:(局部变量）方法代码片段执行的时候，会给该方法分配内存空间，在栈内存中压栈</p>
<p>堆内存：（成员变量）</p>
<p> classname name = new classname();</p>
<p> new运算符在堆内存中开辟的内存空间称为对象</p>
<p>引用，引用保存了内存地址（java对象的内存地址).</p>
<p>堆内存中的对象内部的实例变量只能通过访问</p>
<p>引用.属性；  引用.属性 = newvalue;</p>
<p><img src="/java/image3.png" alt="img"></p>
<p><img src="/java/image4.png" alt="img"></p>
<p>引用的地址的值发生改变，值也发生改变。</p>
<p><img src="/java/image6.png" alt="img"></p>
<p><img src="/java/image7.png" alt="img"></p>
<p>JVM（Java虚拟机）主要包括三块内存空间：分别是栈内存、堆内存、方法区内存</p>
<p>堆内存和方法区内存各有一个，一个线程一个栈内存</p>
<p>方法调用的时候，该方法所需要的内存空间在栈内存中分配，成为压线。方法执行结束之后，该方法所属的内存空间是否，成为弹栈</p>
<p>栈中主要存储的是方法体中的局部变量。</p>
<p>方法体的代码段以及整个类的代码片段都被存储在方法区内存中，在类加载的时候这些代码会载入</p>
<p>在程序执行过程中使用new运算符创建的Java对象，存储在堆内存当中，对象内部有实例变量，所以实例变量存储在堆内存当中。</p>
<p>变量分类:</p>
<p>-局部变量(方法体内声明</p>
<p>-成员变量(方法体外声明</p>
<p>*实例变量（没有static修饰</p>
<p>*静态变量（有static修饰</p>
<p>静态变量存储在方法区内存当中</p>
<p>变化最频繁的是栈内存，最先有数据的是方法区内存。垃圾回收器主要针对的是堆内存</p>
<p><img src="/java/image8.png" alt="img"></p>
<p>垃圾回收器【自动垃圾回收机制，GC机制】在堆内存中的Java对象成为垃圾数据的时候会被垃圾回收器回收。</p>
<p>什么时候堆内存中的Java对象会变成垃圾：</p>
<p>没有更多的引用指向数据的时候会变成垃圾数据。</p>
<p>这个数据无法被访问，因为访问对象只能通过引用的方式访问</p>
<p> 空引用访问实例相关的数据一定会抛出空指针异常</p>
<p>属性通常彩用变量来表示，既然是变量那么变量肯定有数据类型。数据类型：基本数据类型+引用数据类型</p>
<p>每个类中都可以编写主方法，但是一般情况下一个系统只有一个入口</p>
<p><strong>面向对象的封装性</strong></p>
<p>封装的好处：看不到实物复杂的一面</p>
<p>复杂性封装，对外提供简单的操作入口。</p>
<p>封装之后才会形成真正的对象，真正的独立体</p>
<p>封装之后程序可以重复使用</p>
<p>封装后对于事物本身提高了安全性</p>
<p>封装的步骤</p>
<p>1所有属性私有化，使用private进行修饰，修饰的属性只能在类中访问</p>
<p>private int age;</p>
<p>2对外提供简单的操作入口，进行对私有属性访问（set和get方法）</p>
<p>set方法的命名规范 public void set+属性名大写(形参){}&gt;没有返回值</p>
<p>get方法的命名规范 public void set+属性名大写(){}</p>
<p>set和get方法没有static关键字</p>
<p>有static关键字修饰的方法调用：类名.方法（）;</p>
<p>没有static关键字修饰的方法调用：引用.方法名（实参）；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">	age = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IDEA：alt+inset可选择自动生成set和get方法</p>
<h4 id="构造方法（构造函数，构造器）"><a href="#构造方法（构造函数，构造器）" class="headerlink" title="构造方法（构造函数，构造器）"></a>构造方法（构造函数，构造器）</h4><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">**构造方法：</span></span><br><span class="line"><span class="comment">*  1 构造方法又称为构造函数，构造器/constructor</span></span><br><span class="line"><span class="comment">*  2 语法结构：</span></span><br><span class="line"><span class="comment">*       [修饰符列表] 构造方法名(形参列表)&#123;</span></span><br><span class="line"><span class="comment">*               构造方法体;</span></span><br><span class="line"><span class="comment">*           &#125;</span></span><br><span class="line"><span class="comment">*  3 普通方法：</span></span><br><span class="line"><span class="comment">*       [修饰符列表] 返回值类型 构造方法名(形参列表)&#123;</span></span><br><span class="line"><span class="comment">*           方法体</span></span><br><span class="line"><span class="comment">*           &#125;</span></span><br><span class="line"><span class="comment">*  4 对于构造方法来说，返回值类型不需要指定，也不能写void</span></span><br><span class="line"><span class="comment">*  5 构造方法的方法名必须与类名一致</span></span><br><span class="line"><span class="comment">*  6 构造方法的作用：</span></span><br><span class="line"><span class="comment">*       构造方法存在的意义：通过构造方法的调用可以创建对象</span></span><br><span class="line"><span class="comment">*  7 构造方法的调用:</span></span><br><span class="line"><span class="comment">*       普通方法调用：没有static类名.方法名(实参) 有static:引用.方法名(实参列表)</span></span><br><span class="line"><span class="comment">*       构造方法调用：new 构造方法名(实参列表);</span></span><br><span class="line"><span class="comment">*  8 构造方法结束后有返回值。return值不需要编写</span></span><br><span class="line"><span class="comment">*    并且返回值类型是构造方法所在类的类型</span></span><br><span class="line"><span class="comment">*  10 当一个类中没有任何构造方法的话，系统会默认给一个无参的的构造方法，被成为缺省构造器</span></span><br><span class="line"><span class="comment">*   返回了内存地址</span></span><br><span class="line"><span class="comment">*  User u = new User();</span></span><br><span class="line"><span class="comment">*  11 有参数的构造方法</span></span><br><span class="line"><span class="comment">*  12 当一个类的显示方法将构造方法定义出来，不在为这个类提供默认缺省构造器，建议开发中手动为当前类提供无参构造方法</span></span><br><span class="line"><span class="comment">*  13 构造方法支持重载机制，在一个类中编写多个构造方法构成重载机制</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  构造方法的其他作用:</span></span><br><span class="line"><span class="comment">*       创建对象</span></span><br><span class="line"><span class="comment">*       创建对象的同时，初始化实例变量的内存空间。赋值实例变量</span></span><br><span class="line"><span class="comment">*       alt+7 查看此类的所有方法</span></span><br><span class="line"><span class="comment">*       对象没有。实例对象就不会有。实例变量在创建对象的时候声明为0，在构造方法执行的过程中对实例变量开辟内存空间。赋值默认值也是在构造方法执行的时候赋值</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*       加载了类方法也不会有值。</span></span><br></pre></td></tr></table></figure>

<h4 id="对象和引用"><a href="#对象和引用" class="headerlink" title="对象和引用"></a>对象和引用</h4><p>对象：使用new运算符在堆内存中开辟的内存空间为对象</p>
<p>引用：是一个变量，不一定是局部变量，还可能是成员变量，引用保存了对象在堆内存中的地址。所有访问实例想过的数据需要通过引用.方式访问。</p>
<p>只有一个空的引用，访问对象的实例相关的数据会出现空指针异常。</p>
<h5 id="参数的传递"><a href="#参数的传递" class="headerlink" title="参数的传递"></a>参数的传递</h5><p>main方法中的变量是局部变量，i变量本身占有内存空间</p>
<p>i变量本身也有内存地址，i变量保存的是10这个字面值</p>
<p>传递给其他方法是传递的是10</p>
<h5 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h5><p>  this关键字保存地址指向自身<br>  this是一个引用，是一个变量，this变量保存了内存地址指向了自身<br>  this存储在JVM中堆内存Java对象内部<br>  没有static关键字的方法被成为实例方法，使用‘引用，<br>  没有static关键字的变量成为实例变量，必须使用引用.<br>  当一个行为指向的过程中是需要对象参与的，这个方法一定要定义为’实例方法‘不带static关键字,含static的方法不可使用this关键字访问。main方法中没有this<br>  this可以出现在实例方法当中，this指向当前正在指向这个动作的对象</p>
<p>在static方法中不可以直接访问实例变量和实例方法。</p>
<p>this可以使用在构造方法中通过当前构造方法调用其他的构造方法，但是不会创建新的对象。this(实参);只能出现在第一行。</p>
<p>带static的方法，起始既可以采用类名的方式访问，也可以采用引用的方式访问，采用引用的方式去访问，实际上执行的时候和引用指向的对象无关</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thisdemo.javase;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisDemo02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;   </span><br><span class="line">    String name;   </span><br><span class="line">    <span class="keyword">boolean</span> sex; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThisDemo02</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">boolean</span> sex)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.id = id;   </span><br><span class="line">        <span class="keyword">this</span>.name = name;     </span><br><span class="line">        <span class="keyword">this</span>.sex = sex;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThisDemo02</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>(<span class="number">1</span>,<span class="string">&quot;li&quot;</span>,<span class="keyword">true</span>);<span class="comment">//使用此方法调用带参数的构造方法,不会创建新的对象   </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">        ThisDemo02.dosome();   </span><br><span class="line">        dosome();<span class="comment">//    </span></span><br><span class="line">        <span class="keyword">this</span>.doother();  <span class="comment">//报错//     </span></span><br><span class="line">        doother();  <span class="comment">//报错     </span></span><br><span class="line">        ThisDemo02 demo01 = <span class="keyword">new</span> ThisDemo02();    </span><br><span class="line">        demo01.doother(); <span class="comment">//doother     </span></span><br><span class="line">        demo01.run();</span><br><span class="line">    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dosome</span><span class="params">()</span></span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;dosome&quot;</span>);  </span><br><span class="line">    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doother</span><span class="params">()</span></span>&#123;    <span class="comment">//必须先创对象后引用.doother  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;doother&quot;</span>);   </span><br><span class="line">    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;      </span><br><span class="line">        System.out.println(<span class="string">&quot;run&quot;</span>);    </span><br><span class="line">        doother();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h4><p>变量使用static修饰，静态变量在类加载的时候初始化，内存就已开辟，存放在方法区内存中</p>
<p>可以使用类名.以及引用.对静态变量或者方法进行访问</p>
<ol>
<li><p>可以使用static关键字定义静态代码块。在main方法中编写</p>
<p><code> static&#123;    javacode;&#125;</code></p>
</li>
<li><p>静态代码块在类加载时执行，且只执行一次，可在一个类中编写多个，自上而下执行</p>
</li>
<li><p>{javacode;}实例代码块在类中编写，可以写多个，自上而下执行，实例代码块在构造方法执行之前执行。</p>
</li>
<li><p>何时定义方法为静态:</p>
<p>​        当所有的对象执行这个方法的时候，最终产生的影响是一样的，那这个方法不再属于某一个对象动作，可以将这个动作提升为类级别的方法。 静态方法无法直接访问实例变量和实例方法。</p>
</li>
</ol>
<p>  class类中编写内容：</p>
<p>{</p>
<p>​    静态代码块；</p>
<p>​    实例代码块；</p>
<p>​    静态变量；</p>
<p>​    实例变量；</p>
<p>​    构造方法；</p>
<p>​    静态方法；</p>
<p>​    实例方法；</p>
<p>}</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承是面向对象三大特征之一，基本的作用是代码复用，有了继承才有了方法的覆盖和多态机制。</p>
<p>格式：[修饰符列表] class 类名 extends 父类 {类体=属性+方法}</p>
<p>继承只继承单继承，一个类不可继承很多类。一个类可间接继承其他类：B继承A，C继承B。C类间接继承B,A </p>
<p>继承符类的数据：私有的不支持继承，构造方法不支持继承，其他数据都可继承。</p>
<p>一个类没有显示继承任何类，默认继承Javase库中提供的java.lang.object类</p>
<figure class="highlight java"><figcaption><span>继承</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类文件</span></span><br><span class="line"><span class="keyword">package</span> com.extend.javase;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FatherDemo1</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age; </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> age;  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.age = age; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name; </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FatherDemo1</span><span class="params">()</span></span>&#123;    </span><br><span class="line">        <span class="keyword">super</span>();   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类文件</span></span><br><span class="line"><span class="keyword">package</span> com.extend.javase;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son1</span> <span class="keyword">extends</span> <span class="title">FatherDemo1</span></span>&#123;   </span><br><span class="line">    <span class="comment">//private int age;  </span></span><br><span class="line">    <span class="comment">//private String name; </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son1</span><span class="params">()</span></span>&#123;    </span><br><span class="line">        <span class="keyword">super</span>();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试文件</span></span><br><span class="line"><span class="keyword">package</span> com.extend.javase;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testdemo01</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son1 son = <span class="keyword">new</span> Son1();   </span><br><span class="line">        son.setAge(<span class="number">123</span>);      </span><br><span class="line">        son.setName(<span class="string">&quot;123&quot;</span>);   </span><br><span class="line">        System.out.println(son.getAge());    </span><br><span class="line">        System.out.println(son.getName()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方法的覆盖（方法重写）"><a href="#方法的覆盖（方法重写）" class="headerlink" title="方法的覆盖（方法重写）"></a>方法的覆盖（方法重写）</h5><p> 父类中的方法已不满足子类中的方法需求，需要使用方法重写</p>
<p>重写后子类调用的是重写后的方法。方法名相同，形参相同吗。访问权限不能更低，可以更高，抛出异常不能更多，可以更少。</p>
<p>  注意：私有方法不能继承，所以不能覆盖。</p>
<p>​            构造方法不能继承，所以不能覆盖。</p>
<p>​            静态方法不存在覆盖。</p>
<p>​            覆盖只针对方法，不针对属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;        <span class="keyword">super</span>.move();    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ol>
<li><p>多态中的概念：</p>
<ul>
<li><p>向上转型：子类型转换为父类型（自动类型转换)</p>
</li>
<li><p>向下转型：父类型转换为子类型（强制类型转换）【加强制类型转换符】</p>
<p>两种类型之间必须有继承关系</p>
</li>
</ul>
<p><img src="/java/image-20210628225858710.png"></p>
</li>
</ol>
<p>需求：想让</p>
<p><img src="/java/image-20210628234120003.png"></p>
<p>当调用的方法是子类型中特有的，在父类型中不存在，必须进行向下转型。</p>
<p>son so = (son)so;</p>
<p>向下转型存在安全隐患</p>
<p>使用instanceof避免转型出现的classcastexception错误；</p>
<p>instanceof使用：引用 instanceof 数据类型名</p>
<p>结果是布尔类型。真代表引用指向的对象是 数据类型 ，假代表不是 属性类型名</p>
<p>多态的作用：降低代码的耦合</p>
<figure class="highlight java"><figcaption><span>[多态的使用]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">package</span> com.testplo.javase;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fatherdemo02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">package</span> com.testplo.javase;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sondemo02</span> <span class="keyword">extends</span> <span class="title">Fatherdemo02</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//调用类</span></span><br><span class="line"><span class="keyword">package</span> com.testplo.javase;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Motherdemo02</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kiss</span><span class="params">(Fatherdemo02 fa)</span></span>&#123;  </span><br><span class="line">        System.out.println(fa.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;i kiss you!&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类2</span></span><br><span class="line"><span class="keyword">package</span> com.testplo.javase;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Daugterdemo02</span> <span class="keyword">extends</span> <span class="title">Fatherdemo02</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">package</span> com.testplo.javase;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testdemo02</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </span><br><span class="line">        Motherdemo02 mo = <span class="keyword">new</span> Motherdemo02();   </span><br><span class="line">        Fatherdemo02 fa = <span class="keyword">new</span> Fatherdemo02();    </span><br><span class="line">        fa.name = <span class="string">&quot;lise&quot;</span>;    </span><br><span class="line">        Sondemo02 son = <span class="keyword">new</span> Sondemo02();   </span><br><span class="line">        son.name = <span class="string">&quot;bob&quot;</span>;  </span><br><span class="line">        mo.kiss(son);    </span><br><span class="line">        Daugterdemo02 da = <span class="keyword">new</span> Daugterdemo02();   </span><br><span class="line">        da.name = <span class="string">&quot;alice&quot;</span>;  </span><br><span class="line">        mo.kiss(da);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//输出结果bobi kiss you!alicei kiss you!进程已结束，退出代码 0</span></span><br></pre></td></tr></table></figure>

<h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><p>final修饰的类无法被继承</p>
<p>final修饰的方法无法被覆盖</p>
<p>final修饰的变量一旦赋值，不可重新赋值</p>
<p>final修饰的实例变量（实例变量含有默认值），必须手动赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;  </span><br><span class="line">    <span class="comment">//final int a;错误  </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;  <span class="comment">//第一种方法    </span></span><br><span class="line">    <span class="comment">//第二种方法   </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> b;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;    </span><br><span class="line">        <span class="keyword">this</span>.b = <span class="number">200</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>final修饰的引用一旦指向一个对象，不再可以指向新的对象。被指向的对象无法被垃圾回收机制回收。但是指向的对象的内存地址可以修改。</p>
<p>final修饰的实例变量是不可变的，这种变量一般和static联合使用，成为常量。</p>
<p><code>public static final 类型 变量名 = 值</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> User_Name = <span class="string">&quot;张伞&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        System.out.println(A.User_Name);        <span class="comment">//结果为张伞且不可修改  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="package和import"><a href="#package和import" class="headerlink" title="package和import"></a>package和import</h5><p>package成为包，这种机制为了方便程序的管理。</p>
<p>定义package方法</p>
<ol>
<li><p>在Java源程序的第一行编写package语句（只能编写一个语句）</p>
<p>语法结构:package 包名;</p>
</li>
<li><p>包名的命名规范：</p>
<p>公司域名倒序 + 项目名 + 模块名 + 功能名;(全部小写，遵守标识符规则，一个包是一个目录)</p>
<p>e.g：<code>com.baidu.oa.user.service;</code></p>
<p>使用package机制之后，类名改为包名+类名；</p>
</li>
<li><p>编译方法，javac java文件，将生成的class文件到创建的包下，然后java + 类名（全称）。</p>
<p>import 导入类名（全称）；同一个包下的类不需要导入，不同包下的需要导入；需要编写在package之下，class之上。</p>
</li>
</ol>
<h4 id="访问控制权限修饰符"><a href="#访问控制权限修饰符" class="headerlink" title="访问控制权限修饰符"></a>访问控制权限修饰符</h4><ol>
<li>访问控制权限来控制元素的访问范围</li>
<li>访问控制权限修饰符包括：<ul>
<li>public    表示公开的，任何位置都可访问</li>
<li>protected 同包、子类</li>
<li>缺省  同包</li>
<li>private  表示私有的，只能在本类访问</li>
</ul>
</li>
<li>可以修饰类、变量、方法</li>
<li>当某个数据只希望子类使用，使用protected进行修饰。</li>
<li>修饰符的范围：private &lt; 缺省 &lt; protected &lt; public</li>
</ol>
<h6 id="super"><a href="#super" class="headerlink" title="super()"></a>super()</h6><p>super是一个关键字</p>
<p>this只能出现在实例方法和构造方法中，不可使用在静态方法中。</p>
<p>this()只能出现在构造方法第一行，通过当前的构造方法去调用本类中其他的构造方法，代码复用。</p>
<p>super能出现在实例方法和构造方法中，不能使用在静态方法中，super.大部分情况可以省略，？？？？</p>
<p>super()只能出现在构造方法第一行，通过当前的构造方法去调用父类中的构造方法，目的：代码复用（创建子类对象的时候，先初始化父类型特征）</p>
<p>super()表示通过子类的构造方法调用父类的构造方法。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.superdemo.javase;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperDemo01</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">        B b = <span class="keyword">new</span> B();        <span class="comment">//A的构造方法        </span></span><br><span class="line">        <span class="comment">//B的构造方法   </span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;  </span><br><span class="line">                System.out.println(<span class="string">&quot;A的构造方法&quot;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;  </span><br><span class="line">                System.out.println(a);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123; </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;      </span><br><span class="line">                <span class="keyword">super</span>();        <span class="comment">//super(199); //调用带参数的父类构造方法     </span></span><br><span class="line">                System.out.println(<span class="string">&quot;B的构造方法&quot;</span>);   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//子类默认调用父类的无参构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this()与super()不可共存，父类的构造方法一定先执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperDemo01</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">        B b = <span class="keyword">new</span> B();        <span class="comment">//A的构造方法        //B的构造方法    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;A的构造方法&quot;</span>);   </span><br><span class="line">    &#125;    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;  </span><br><span class="line">        System.out.println(a);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>(<span class="string">&quot;hello world&quot;</span>);    </span><br><span class="line">        System.out.println(<span class="string">&quot;B的构造方法&quot;</span>); </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(String b)</span></span>&#123;    </span><br><span class="line">        System.out.println(<span class="string">&quot;B带参数的构造方法&quot;</span>)  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//A的构造方法</span></span><br><span class="line"><span class="comment">//B带参数的构造方法</span></span><br><span class="line"><span class="comment">//B的构造方法/*主方法中调用B类中的无参构造方法，在允许中，先执行父类A的无参构造方法，然后执行B类的带参构造方法，最后输出B的构造方法</span></span><br></pre></td></tr></table></figure>

<p>super()的作用是初始化当前对象的父类型特征，并不是创建对象，实际上对象只创建了一个</p>
<p>super关键字代表的是当前对象的那部分父类型特征。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.superdemo.javase;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperDemo03</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        F f = <span class="keyword">new</span> F(<span class="keyword">false</span>,<span class="string">&quot;zs&quot;</span>,<span class="number">14</span>);   </span><br><span class="line">        System.out.println(f.getAge() + <span class="string">&quot;:&quot;</span> + f.getName() +<span class="string">&quot;:&quot;</span> + f.isSex());<span class="comment">//通过super方法调用父类的构造函数以对private属性进行访问   </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">E</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">E</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;    </span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name; </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">return</span> age; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> <span class="keyword">extends</span> <span class="title">E</span></span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> sex;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">F</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">F</span><span class="params">(<span class="keyword">boolean</span> sex,String name,<span class="keyword">int</span> age)</span></span>&#123;   </span><br><span class="line">        <span class="keyword">super</span>(name,age);    </span><br><span class="line">        <span class="keyword">this</span>.sex = sex;   </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSex</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> sex;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/java/image9.png" alt="image-20210630233325003"></p>
<p> 子类中同名变量出现会将子类的变量值赋值Null</p>
<p>同名属性访问父类的特征必须使用super(不可省略)访问</p>
<p>super不是引用，不保存内存地址，不指向任何对象。仅代表当前对象的父类型的特征。</p>
<p>super.attr;访问父类的属性</p>
<p>super.func();访问父类的方法</p>
<p>super();调用父类的构造方法</p>
<p>this.attr;访问本类的属性</p>
<p>this.func();调用本类的方法</p>
<p>this();调用本类的构造方法</p>
<p>System.exit(0);退出Java虚拟机</p>
<h5 id="final-1"><a href="#final-1" class="headerlink" title="final"></a>final</h5><ol>
<li>final是Java语言中的关键字</li>
<li>表示最终的，不可变的。</li>
<li>可修饰遍历和方法和类</li>
<li>final修饰的变量不可再次赋值</li>
<li>final修饰的方法无法被覆盖，重写</li>
<li>final修饰的类不可被继承</li>
<li>final修饰的变量是一个引用，不可再重新赋值，该引用只能指向一个对象，并且它只能永远指向该对象，无法再指向其他对象，并且在该方法指向过程中，该引用指向该对象之后，该对象不会被垃圾回收器回收。引用指向的对象的值是可以改的。</li>
<li>final修饰的实例变量，必须手动赋值 final int a = value;或者在构造方法中再赋值</li>
<li>final修饰的实例变量一般添加static修饰改为静态变量，存储再方法区，成为常量，常量全部大写，常量和静态变量一样，但是常量的值不可变，都存在方法区，可以公开</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.finademo.javase;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalDemo02</span> </span>&#123; </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">100</span>;   </span><br><span class="line">    a = <span class="number">10000</span>; <span class="comment">//此行报错  </span></span><br><span class="line">    Fa fa = <span class="keyword">new</span> Fa();  </span><br><span class="line">    fa = <span class="keyword">new</span> son(); <span class="comment">//报错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fa</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;     </span><br><span class="line">        System.out.println(<span class="string">&quot;eat&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span> <span class="keyword">extends</span> <span class="title">Fa</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;  <span class="comment">//此行报错   </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>描述： 类与类之间具有共同特征，将共同特征提取出来，形成的就是抽象类，抽象类是用来被继承，abstract与final不可联合使用</p>
<p>抽象类无法实例化对象</p>
<p>语法： [修饰符列表] abstract class 类名{}</p>
<p>抽象关联到抽象方法：抽象方法表示没有实现的方法，没有方法体的方法 public abstract void functionname();抽象方法必须出现在抽象类中</p>
<p><strong>非抽象子类继承抽象类中抽象方法必须进行实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">classname</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">functionname</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">animass</span></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">bird</span> <span class="keyword">extends</span> <span class="title">animass</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">yingwu</span> <span class="keyword">extends</span> <span class="title">bird</span></span>&#123; </span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//必须进行重写   </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口也是一种引用类型。完全抽象，（抽象类是半抽象）,编译后也是class字节码文件，</p>
<p>接口可以继承接口，且可以多继承，</p>
<p>接口只能包含常量以及抽象方法。</p>
<p>抽象方法的abstract和public可以省略，接口中所有的元素都是public修饰的，接口中的方法不可以有方法体</p>
<p>接口中的常量的public static final可以省略 </p>
<p>基础语法：</p>
<p>[修饰符列表] interface 接口名{}</p>
<p>int a = 10;  a为常量</p>
<p>抽象类与接口的区别 </p>

                <hr>
                

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/test/" data-toggle="tooltip" data-placement="top"
                           title="mongodb数据库mongod启动返回码100解决">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/processing/" data-toggle="tooltip" data-placement="top"
                           title="Python多进程实现文件夹下内容的复制">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                

                


                <!--加入新的评论系统-->
                

                
                    <!-- Valine -->
                    <div class="vcomments"></div>
                    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
                    <script src="//cdn.jsdelivr.net/npm/valine"></script>
                    <script>
                        var GUEST = ['nick','mail','link'];
                        var meta = '';
                        meta = meta.split(',').filter(function (item) {
                            return GUEST.indexOf(item)>-1;
                        });
                        var notify = 'false' == true ? true : false;
                        var verify = 'false' == true ? true : false;
                        new Valine({
                            el: '.vcomments',
                            notify: notify,
                            verify: verify,
                            app_id: "oE8RJ9DO5Tl7ChTtMFwgLKIg-gzGzoHsz",
                            app_key: "mUbPBB3Wq3R6wX9ysIlescWj",
                            placeholder: "评论一下",
                            avatar:"mm",
                            meta:meta
                        });
                    </script>
                

            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="toc-text">Java语言基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">Java修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%88%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%89"><span class="toc-text">构造方法（构造函数，构造器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-text">对象和引用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92"><span class="toc-text">参数的传递</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">this关键字</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">static关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E8%A6%86%E7%9B%96%EF%BC%88%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%EF%BC%89"><span class="toc-text">方法的覆盖（方法重写）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#final"><span class="toc-text">final</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#package%E5%92%8Cimport"><span class="toc-text">package和import</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">访问控制权限修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#super"><span class="toc-text">super()</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#final-1"><span class="toc-text">final</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-text">接口</span></a></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5 class="text-center">
                        <a href="/tags/">FEATURED TAGS</a>
                    </h5>
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#Java"
                           title="Java">Java</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <div style="margin-top: 20px;">
                    <h5 class="text-center">FRIENDS</h5>
                    <ul class="list-inline text-center">
                        
                        <li><a target="_blank" rel="noopener" href="https://www.zerochen.top">墨的博客</a></li>
                        
                        <li><a target="_blank" rel="noopener" href="https://www.sunflowers.vip">sunflowers的博客</a></li>
                        
                    </ul>
                </div>
                
            </div>
        </div>

    </div>
</article>







<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/mar-mot">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; marmot 2021
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
                    <br>
                    Theme by <a target="_blank" rel="noopener" href="https://haojen.github.io/">Haojen Ma</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/blog.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://www.marmot.vip/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>



<!-- Google Analytics -->



<!-- Baidu Tongji -->


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','','2.0.0');
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="/img/marmot.jpg">
</body>

</html>
